var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumStateTransfer","category":"page"},{"location":"#QuantumStateTransfer","page":"Home","title":"QuantumStateTransfer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantumStateTransfer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QuantumStateTransfer]","category":"page"},{"location":"#QuantumStateTransfer.OptimizedStateTransfer","page":"Home","title":"QuantumStateTransfer.OptimizedStateTransfer","text":"OptimizedStateTransfer\n\nA struct to store data on optimized state transfer between all qubit pairs in a network.\n\nFields\n\nadjacency_matrix::AbstractMatrix{<:Real}: The network in adjacency_matrix format.\nexhibits_pst::Bool: Whether the quantum network exhibits perfect state transfer\n\nbetween any pair of qubits.\n\nqubit_pairs::Base.Generator: A lazily evaluated generator of structs containing\n\ndata on state transfer between every pair of qubits in the network.\n\n\n\n\n\n","category":"type"},{"location":"#QuantumStateTransfer.QubitPairTransfer","page":"Home","title":"QuantumStateTransfer.QubitPairTransfer","text":"QubitPairTransfer\n\nA struct to store data on optimized state transfer between two qubits in a quantum network.\n\nFields\n\nsource::Int: The index of the source qubit.\ndest::Int: The index of the target qubit.\nis_pst::Bool: Whether there is perfect state transfer from the source qubit to the\n\ntarget qubit (i.e., whether maximum_fidelity is sufficiently close to 1).\n\nmaximum_fidelity::Float64: The (numerically approximated) maximum transfer fidelity from\n\nthe source qubit to the target qubit.\n\noptimal_time::Float64: The time at which the maximum transfer fidelity is achieved.\n\n\n\n\n\n","category":"type"},{"location":"#QuantumStateTransfer.UnitaryEvolution","page":"Home","title":"QuantumStateTransfer.UnitaryEvolution","text":"UnitaryEvolution\n\nA struct to store data on the unitary evolution of a quantum network.\n\nFields\n\nadjacency_matrix::AbstractMatrix{<:Real}: The network in adjacency_matrix format.\ntime_steps::AbstractVector{<:Real}: The times at which to track state amplitudes.\ntransfer_amplitudes::Array{ComplexF64, 3}: The amplitudes of state transfer between\n\nqubits. The first dimension corresponds to the time step, the second corresponds to the target qubit, and the third corresponds to the source qubit.\n\ntransfer_fidelities::Array{Float64, 3}: The magnitudes of the transfer amplitudes\n\nsquared, representing wave function probabilities rather than amplitudes.\n\n\n\n\n\n","category":"type"},{"location":"#QuantumStateTransfer.optimized_state_transfer-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"QuantumStateTransfer.optimized_state_transfer","text":"optimized_state_transfer(adj_mat::AbstractMatrix{<:Real}; kwargs...)\noptimized_state_transfer(graph::AbstractGraph{Int}; kwargs...)\n\nAdd later\n\nArguments\n\nAdd later\n\nKeywords\n\nSee qubit_pair_transfer documentation for more information. (The set of valid keyword arguments is exactly the same for both functions, as qubit_pair_transfer is a helper function for optimized_state_transfer.)\n\nReturns\n\nAdd later\n\nExamples\n\nAdd later ```\n\n\n\n\n\n","category":"method"},{"location":"#QuantumStateTransfer.qubit_pair_transfer-Tuple{AbstractMatrix{<:Real}, Int64, Int64}","page":"Home","title":"QuantumStateTransfer.qubit_pair_transfer","text":"qubit_pair_transfer(\n    adj_mat::AbstractMatrix{<:Real}, source::Int, dest::Int;\n    min_time::Real=0,\n    max_time::Real=12.566370614359172,\n    tol::Real=1.0e-5,\n)\nqubit_pair_transfer(graph::AbstractGraph{Int}, source::Int, dest::Int; kwargs...)\n\nFind the maximized fidelity of state transfer between two qubits and the associated time.\n\nArguments\n\nadj_mat::AbstractMatrix{<:Real}: The quantum network in adjacency_matrix format.\ngraph::AbstractGraph{Int}: The network in graph format. (Only passed when adj_mat is\n\nnot provided.)\n\nsource::Int: The index of the source qubit (assumed to have an initial state of the\n\nsource-th standard basis vector).\n\ndest::Int: The index of the target qubit (assumed to have an initial state of the\n\ndest-th standard basis vector).\n\nKeywords\n\nmin_time::Real=0: The minimum time at which state transfer is considered.\nmax_time::Real=12.566370614359172: The maximum time at which state transfer is considered.\ntol::Real=1.0e-5: The margin of error for determining whether perfect state transfer\n\noccurs between the source and target.\n\nReturns\n\nQubitPairTransfer: A struct containing data on the optimized state transfer. Also\n\nindicates whether PST was found between the two qubits.\n\nExamples\n\n```jldoctest julia> using Graphs: Graph\n\njulia> C4_adj = BitMatrix([0 1 0 1; # Cycle graph on 4 vertices (adj. matrix format)                            1 0 1 0;                            0 1 0 1;                            1 0 1 0]);\n\njulia> C4graph = Graph(C4adj); # Cycle graph on 4 vertices (graph format)\n\njulia> qubitpairtransfer(C4_adj, 1, 2) # There is no PST from node 1 to node 2 QubitPairTransfer(1, 2, false, 0.25, 2.35619)\n\njulia> qubitpairtransfer(C4_graph, 1, 3) # There is PST from node 1 to node 3 over time π/2 QubitPairTransfer(1, 3, true, 1.0, 1.5708)\n\n\n\n\n\n","category":"method"},{"location":"#QuantumStateTransfer.track_qubit_amplitude-Tuple{AbstractMatrix{<:Real}, Int64}","page":"Home","title":"QuantumStateTransfer.track_qubit_amplitude","text":"track_qubit_amplitude(\n    adj_mat::AbstractMatrix{<:Real}, source::Int;\n    dests::AbstractVector{Int}=1:size(adj_mat, 1),\n    time_steps::AbstractVector{<:Real}=0:(π / 200):5,\n)\ntrack_qubit_amplitude(graph::AbstractGraph{Int}, source::Int; kwargs...)\n\nTracks the wave function amplitude of a qubit in a quantum network over time.\n\nArguments\n\nadj_mat::AbstractMatrix{<:Real}: The quantum network in adjacency_matrix format.\ngraph::AbstractGraph{Int}: The network in graph format. (Only passed when adj_mat is\n\nnot provided.)\n\nsource::Int: The qubit whose wave function amplitude to track.\n\nKeywords\n\ndests::AbstractVector{Int}=1:size(adj_mat, 1): The qubits at which to track the wave\n\nfunction amplitude of source.\n\ntime_steps::AbstractVector{<:Real}=0:(π / 200):5: The times at which to track the wave\n\nfunction amplitude of source.\n\nReturns\n\nMatrix{ComplexF64}: The transfer amplitudes of source to each qubit in dests at each\n\ntime step. The first dimension corresponds to the time step, and the second corresponds to the target qubit.\n\nExamples\n\njulia> using Graphs: wheel_graph\n\njulia> g = wheel_graph(8); source = 3; dests = [2, 4, 7]; time_steps = 0:1:5;\n\njulia> amps_3_to_247 = track_qubit_amplitude(g, source, dests=dests, time_steps=time_steps)\n6×3 Matrix{ComplexF64}:\n        0.0-0.0im               0.0-0.0im               0.0-0.0im\n -0.0282559+0.340869im   -0.0282559+0.340869im   0.00691979-0.364799im\n  0.0270747+0.159635im    0.0270747+0.159635im     0.353068-0.20453im\n  -0.248756-0.288904im    -0.248756-0.288904im     0.291226-0.129163im\n  -0.158849+0.0938213im   -0.158849+0.0938213im   -0.210858+0.121758im\n   0.500422+0.160662im     0.500422+0.160662im    -0.259143-0.0882654im\n\n\n\n\n\n","category":"method"},{"location":"#QuantumStateTransfer.unitary_evolution","page":"Home","title":"QuantumStateTransfer.unitary_evolution","text":"unitary_evolution(\n    adj_mat::AbstractMatrix{<:Real}, time_steps::AbstractVector{<:Real}=0:(π / 200):5,\n)\nunitary_evolution(\n    graph::AbstractGraph{Int}, time_steps::AbstractVector{<:Real}=0:(π / 200):5,\n)\n\nSimulates unitary evolution on a quantum network in the idealized absence of noise.\n\nArguments\n\nadj_mat::AbstractMatrix{<:Real}: The quantum network in adjacency_matrix format.\ngraph::AbstractGraph{Int}: The network in graph format. (Only passed when adj_mat is\n\nnot provided.)\n\nKeywords\n\ntime_steps::AbstractVector{<:Real}=0:(π / 200):5: The times at which to track state\n\ntransfer between qubits.\n\nReturns\n\nUnitaryEvolution: A struct storing data on the unitary evolution of the quantum network.\n\nMost notably, contains the amplitude and fidelity of state transfer between each pair of qubits at every time step.\n\nExamples\n\njulia> using Graphs: complete_bipartite_graph\n\njulia> g = complete_bipartite_graph(1, 2); time_steps = LinRange(0, π, 7);\n\njulia> evolution = unitary_evolution(g, time_steps); # Simulate state transfer on K₁₂\n\njulia> evolution.adjacency_matrix # Adjacency matrix of the complete bipartite graph K₁₂\n3×3 BitMatrix:\n 0  1  1\n 1  0  0\n 1  0  0\n\njulia> evolution.time_steps # Time steps at which to measure state transfer\n7-element LinRange{Float64, Int64}:\n 0.0, 0.523599, 1.0472, 1.5708, 2.0944, 2.61799, 3.14159\n\njulia> evolution.transfer_amplitudes # State transfer amplitudes between qubits\n7×3×3 Array{ComplexF64, 3}:\n[:, :, 1] =\n       1.0-0.0im  0.0-0.0im       0.0-0.0im\n  0.738144-0.0im  0.0+0.477044im  0.0+0.477044im\n 0.0897146-0.0im  0.0+0.704255im  0.0+0.704255im\n   -0.6057-0.0im  0.0+0.56264im   0.0+0.56264im\n -0.983903-0.0im  0.0+0.126364im  0.0+0.126364im\n -0.846825-0.0im  0.0-0.37609im   0.0-0.37609im\n -0.266255-0.0im  0.0-0.681582im  0.0-0.681582im\n\n[:, :, 2] =\n 0.0-0.0im             1.0-0.0im        0.0-0.0im\n 0.0+0.477044im   0.869072-0.0im  -0.130928-0.0im\n 0.0+0.704255im   0.544857-0.0im  -0.455143-0.0im\n 0.0+0.56264im     0.19715-0.0im   -0.80285-0.0im\n 0.0+0.126364im  0.0080487-0.0im  -0.991951-0.0im\n 0.0-0.37609im   0.0765877-0.0im  -0.923412-0.0im\n 0.0-0.681582im   0.366872-0.0im  -0.633128-0.0im\n\n[:, :, 3] =\n 0.0-0.0im             0.0-0.0im        1.0-0.0im\n 0.0+0.477044im  -0.130928-0.0im   0.869072-0.0im\n 0.0+0.704255im  -0.455143-0.0im   0.544857-0.0im\n 0.0+0.56264im    -0.80285-0.0im    0.19715-0.0im\n 0.0+0.126364im  -0.991951-0.0im  0.0080487-0.0im\n 0.0-0.37609im   -0.923412-0.0im  0.0765877-0.0im\n 0.0-0.681582im  -0.633128-0.0im   0.366872-0.0im\n\njulia> evolution.transfer_fidelities # State transfer fidelities between qubits\n7×3×3 Array{Float64, 3}:\n[:, :, 1] =\n 1.0        0.0        0.0\n 0.544857   0.227571   0.227571\n 0.0080487  0.495976   0.495976\n 0.366872   0.316564   0.316564\n 0.968064   0.0159678  0.0159678\n 0.717112   0.141444   0.141444\n 0.0708919  0.464554   0.464554\n\n[:, :, 2] =\n 0.0        1.0         0.0\n 0.227571   0.755287    0.0171421\n 0.495976   0.296869    0.207155\n 0.316564   0.0388681   0.644568\n 0.0159678  6.47816e-5  0.983967\n 0.141444   0.00586567  0.85269\n 0.464554   0.134595    0.400851\n\n[:, :, 3] =\n 0.0        0.0        1.0\n 0.227571   0.0171421  0.755287\n 0.495976   0.207155   0.296869\n 0.316564   0.644568   0.0388681\n 0.0159678  0.983967   6.47816e-5\n 0.141444   0.85269    0.00586567\n 0.464554   0.400851   0.134595\n\n\n\n\n\n","category":"function"}]
}
