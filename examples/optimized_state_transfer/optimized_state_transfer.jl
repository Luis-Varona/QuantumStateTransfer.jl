using QuantumStateTransfer: optimized_state_transfer
using Graphs


"""
    hypercube_graph(n::Int)

Construct the `n`-hypercube graph.

The hypercube in `n` dimensions is generated by taking the Cartesian product of `n` copies
of the complete graph on 2 vertices. (The resulting product has exactly `2ⁿ` vertices.)

# Arguments
- `n::Int`: The dimension of the hypercube.

# Returns
- `Graph{Int64}`: A `Graph` representation of the `n`-hypercube.
"""
function hypercube_graph(n::Int)
    hc = Graph(1)
    k2 = complete_graph(2)
    
    for _ in 1:n
        hc = cartesian_product(hc, k2)
    end
    
    return hc
end


N = 4

for n in 1:N
    hc = hypercube_graph(n)
    @info "Data on state transfer on the $n-hypercube:"
    
    @time begin
        for (i, qpt) in enumerate(
            collect(optimized_state_transfer(hc, tol=1e-2).qubit_pairs),
        )
            println("($i) $qpt")
        end
    end
    
    println()
end


n = 14
p = 0.91
g = erdos_renyi(n, p)
@info "Data on state transfer on a G(n=$n, p=$p) Erdős–Rényi random graph:"

@time begin
    for (i, qpt) in enumerate(collect(optimized_state_transfer(g).qubit_pairs))
        println("($i) $qpt")
    end
end
