module TestOptimizedStateTransfer

using Test
using QuantumStateTransfer: optimized_state_transfer, qubit_pair_transfer
using Graphs


C4_adj = BitMatrix([0 1 0 1;
                    1 0 1 0;
                    0 1 0 1;
                    1 0 1 0]);
C4_graph = Graph(C4_adj);

source = 1
dest1 = 2
dest2 = 3

maximum_fidelity1 = 1 / 4
is_pst2 = true
is_optimal_time1(time::Real) = time % 2π ≈ 3π / 4
is_optimal_time2(time::Real) = time % 2π ≈ π / 2


@time @testset "qubit_pair_transfer" begin
    qpt1 = qubit_pair_transfer(C4_adj, source, dest1)
    qpt2 = qubit_pair_transfer(C4_graph, source, dest2)
    
    @test qpt1.maximum_fidelity ≈ maximum_fidelity1
    @test qpt2.is_pst == is_pst2
    @test is_optimal_time1(qpt1.optimal_time)
    @test is_optimal_time2(qpt2.optimal_time)
end


"""
    hypercube_graph(n::Int)

Construct the `n`-hypercube graph.

The hypercube in `n` dimensions is generated by taking the Cartesian product of `n` copies
of the complete graph on 2 vertices. (The resulting product has exactly `2ⁿ` vertices.)

# Arguments
- `n::Int`: The dimension of the hypercube.

# Returns
- `Graph{Int64}`: A `Graph` representation of the `n`-hypercube.
"""
function hypercube_graph(n::Int)
    hc = Graph(1)
    k2 = complete_graph(2)
    
    for _ in 1:n
        hc = cartesian_product(hc, k2)
    end
    
    return hc
end


# TODO: Use matrix power trick for each row instead?
"""
    hypercube_pst_pairs(n::Int)

Find all qubit pairs in the `n`-hypercube between which PST should theoretically occur.

Perfect state transfer has been shown to occur between all qubit pairs in the `n`-hypercube
between which the shortest path length is precisely `n`. (See `Johnston et al. 2017` at
https://doi.org/10.1016/j.laa.2017.05.037.)

This function uses Dijkstra's algorithm, which will always return the correct shortest path
length, as the hypercube is unweighted.

# Arguments
- `n::Int`: The dimension of the hypercube.

# Returns
- `Vector{Tuple{Int, Int}}`: A vector of tuples containing the indices of (unordered) PST
qubit pairs in the `n`-hypercube.
"""
function hypercube_pst_pairs(n::Int)
    pst_pairs = Tuple{Int, Int}[]
    num_nodes = (n == 0) ? 0 : 2^n
    nodes = 1:num_nodes
    marked = falses(num_nodes)
    
    hc = hypercube_graph(n)
    dijkstra_states = map(u -> dijkstra_shortest_paths(hc, u), nodes)
    
    for u in nodes
        if !marked[u]
            marked[u] = true
            v = findfirst(isequal(n), dijkstra_states[u].dists)
            pair = u < v ? (u, v) : (v, u)
            marked[v] || (marked[v] = true; push!(pst_pairs, pair))
        end
    end
    
    return pst_pairs
end


N = 5
hypercubes = map(hypercube_graph, 1:N)
pst_pairs_theory = map(hypercube_pst_pairs, 1:N)

@time @testset "optimized_state_transfer" begin
    for n in 1:N
        all_pairs = collect(optimized_state_transfer(hypercubes[n]).qubit_pairs)
        pst_pairs_actual = map(
            qpt -> (qpt.source, qpt.dest),
            filter(qpt -> qpt.is_pst, all_pairs)
        )
        @test pst_pairs_theory[n] == pst_pairs_actual
    end
end

end